{"_id":"hashery","_rev":"3-d0f01887f21eb4ac45e1e8efc66efba0","name":"hashery","dist-tags":{"latest":"1.2.0"},"versions":{"1.0.0":{"name":"hashery","version":"1.0.0","keywords":["webcrypto","crypto.subtle","object-hash","hash","hashing","sha256","sha512","digest","deterministic","stable-hash","json-hash","browser-compatible","native-crypto","secure","standards-based","nodejs","typescript","esmodule","lightweight","fast","modern","object"],"author":{"name":"Jared Wray","email":"me@jaredwray.com"},"license":"MIT","_id":"hashery@1.0.0","maintainers":[{"name":"jaredwray","email":"me@jaredwray.com"}],"homepage":"https://github.com/jaredwray/hashery#readme","bugs":{"url":"https://github.com/jaredwray/hashery/issues"},"dist":{"shasum":"1c24865e6c68874678c379f4ffb84e9153f84e18","tarball":"https://registry.npmjs.org/hashery/-/hashery-1.0.0.tgz","fileCount":11,"integrity":"sha512-ah+O2l/9kuh7tKigRulCT2mxu83US1PEHOiXIAI2h5dHSGurioH9+hWlWIlQOLxr8gtsWA+r7Rr5F+PWTNpb9g==","signatures":[{"sig":"MEUCIQCKQOj5h0NtSwNOLwztAjqiSc0g/FMDTeWhS7djFEKEdAIgHGK/G2YVqYYtHq3ly8cTa7l/kjbEmDnwMHi74ALoaFE=","keyid":"SHA256:DhQ8wR5APBvFHLF/+Tc+AYvPOdTpcIDqOhxsBHRwC7U"}],"unpackedSize":230448},"main":"dist/node/index.cjs","type":"module","types":"dist/node/index.d.ts","module":"dist/node/index.js","engines":{"node":">=20"},"exports":{".":{"import":"./dist/node/index.js","require":"./dist/node/index.cjs"},"./browser":{"import":"./dist/browser/index.js","default":"./dist/browser/index.global.js"}},"gitHead":"a302ffe0b47be62c596eadd779f2cfba29b353cf","scripts":{"lint":"biome check --write --error-on-warnings","test":"pnpm lint && vitest run --coverage","build":"rimraf ./dist && tsup","clean":"rimraf ./dist ./coverage ./node_modules ./pnpm-lock.yaml ./site/README.md ./site/dist","prepare":"pnpm build","test:ci":"biome check --error-on-warnings && vitest run --coverage","benchmark":"tsx benchmark/hashing.ts","website:build":"rimraf ./site/README.md ./site/dist && pnpm docula","website:serve":"rimraf ./site/README.md ./site/dist && pnpm docula"},"_npmUser":{"name":"jaredwray","email":"me@jaredwray.com"},"repository":{"url":"git+https://github.com/jaredwray/hashery.git","type":"git"},"_npmVersion":"10.9.4","description":"Browser Compatible Object Hashing","directories":{},"_nodeVersion":"22.21.1","dependencies":{"hookified":"^1.13.0"},"_hasShrinkwrap":false,"devDependencies":{"tsx":"^4.20.6","tsup":"^8.5.0","docula":"^0.31.0","rimraf":"^6.1.0","vitest":"^4.0.8","tinybench":"^5.1.0","typescript":"^5.9.3","@types/node":"^24.10.1","@biomejs/biome":"^2.3.5","@faker-js/faker":"^10.1.0","@vitest/coverage-v8":"^4.0.8","@monstermann/tinybench-pretty-printer":"^0.2.0"},"_npmOperationalInternal":{"tmp":"tmp/hashery_1.0.0_1762936875312_0.8174236906004626","host":"s3://npm-registry-packages-npm-production"}},"1.1.0":{"name":"hashery","version":"1.1.0","keywords":["webcrypto","crypto.subtle","object-hash","hash","hashing","sha256","sha512","digest","deterministic","stable-hash","json-hash","browser-compatible","native-crypto","secure","standards-based","nodejs","typescript","esmodule","lightweight","fast","modern","object"],"author":{"name":"Jared Wray","email":"me@jaredwray.com"},"license":"MIT","_id":"hashery@1.1.0","maintainers":[{"name":"jaredwray","email":"me@jaredwray.com"}],"homepage":"https://github.com/jaredwray/hashery#readme","bugs":{"url":"https://github.com/jaredwray/hashery/issues"},"dist":{"shasum":"e73dc9a91f0c21c0dbe34496b97370bb02e87a0a","tarball":"https://registry.npmjs.org/hashery/-/hashery-1.1.0.tgz","fileCount":11,"integrity":"sha512-EyN4e8SXi0UIMcDedVVzxbhRzMhhiFYZUfZezPV7bgW2Q6U6ODgAKbCrq6ipUa6ZbOf7KXBVQ2Y6DbGkfTCEtA==","signatures":[{"sig":"MEQCIHiO0qfDWjY+nS85M8pldb4ng9iVRqvcvoDkCqhioG5hAiAfquL65cujxUB+/NBMOlEPKkS8vzzFp403JQ+eSkHOlw==","keyid":"SHA256:DhQ8wR5APBvFHLF/+Tc+AYvPOdTpcIDqOhxsBHRwC7U"}],"unpackedSize":254854},"main":"dist/node/index.cjs","type":"module","types":"dist/node/index.d.ts","module":"dist/node/index.js","engines":{"node":">=20"},"exports":{".":{"import":"./dist/node/index.js","require":"./dist/node/index.cjs"},"./browser":{"import":"./dist/browser/index.js","default":"./dist/browser/index.global.js"}},"gitHead":"60cea5cd2a62b598a852d7869f241f6e4777fee6","scripts":{"lint":"biome check --write --error-on-warnings","test":"pnpm lint && vitest run --coverage","build":"rimraf ./dist && tsup","clean":"rimraf ./dist ./coverage ./node_modules ./pnpm-lock.yaml ./site/README.md ./site/dist","prepare":"pnpm build","test:ci":"biome check --error-on-warnings && vitest run --coverage","benchmark":"tsx benchmark/hashing.ts","website:build":"rimraf ./site/README.md ./site/dist && pnpm docula","website:serve":"rimraf ./site/README.md ./site/dist && pnpm docula"},"_npmUser":{"name":"jaredwray","email":"me@jaredwray.com"},"repository":{"url":"git+https://github.com/jaredwray/hashery.git","type":"git"},"_npmVersion":"10.9.4","description":"Browser Compatible Object Hashing","directories":{},"_nodeVersion":"22.21.1","dependencies":{"hookified":"^1.13.0"},"_hasShrinkwrap":false,"devDependencies":{"tsx":"^4.20.6","tsup":"^8.5.0","docula":"^0.31.0","rimraf":"^6.1.0","vitest":"^4.0.8","tinybench":"^5.1.0","typescript":"^5.9.3","@types/node":"^24.10.1","@biomejs/biome":"^2.3.5","@faker-js/faker":"^10.1.0","@vitest/coverage-v8":"^4.0.8","@monstermann/tinybench-pretty-printer":"^0.2.0"},"_npmOperationalInternal":{"tmp":"tmp/hashery_1.1.0_1762970283221_0.3179244434789823","host":"s3://npm-registry-packages-npm-production"}},"1.2.0":{"name":"hashery","version":"1.2.0","description":"Browser Compatible Object Hashing","type":"module","main":"dist/node/index.cjs","module":"dist/node/index.js","exports":{".":{"import":"./dist/node/index.js","require":"./dist/node/index.cjs"},"./browser":{"import":"./dist/browser/index.js","default":"./dist/browser/index.global.js"}},"types":"dist/node/index.d.ts","repository":{"type":"git","url":"git+https://github.com/jaredwray/hashery.git"},"author":{"name":"Jared Wray","email":"me@jaredwray.com"},"engines":{"node":">=20"},"license":"MIT","scripts":{"clean":"rimraf ./dist ./coverage ./node_modules ./pnpm-lock.yaml ./site/README.md ./site/dist","build":"rimraf ./dist && tsup","prepare":"pnpm build","benchmark":"tsx benchmark/hashing.ts","lint":"biome check --write --error-on-warnings","test":"pnpm lint && vitest run --coverage","test:ci":"biome check --error-on-warnings && vitest run --coverage","website:build":"rimraf ./site/README.md ./site/dist && pnpm docula","website:serve":"rimraf ./site/README.md ./site/dist && pnpm docula"},"dependencies":{"hookified":"^1.13.0"},"devDependencies":{"@biomejs/biome":"^2.3.5","@faker-js/faker":"^10.1.0","@monstermann/tinybench-pretty-printer":"^0.2.0","@types/node":"^24.10.1","@vitest/coverage-v8":"^4.0.8","docula":"^0.31.0","rimraf":"^6.1.0","tinybench":"^5.1.0","tsup":"^8.5.0","tsx":"^4.20.6","typescript":"^5.9.3","vitest":"^4.0.8"},"keywords":["webcrypto","crypto.subtle","object-hash","hash","hashing","sha256","sha512","digest","deterministic","stable-hash","json-hash","browser-compatible","native-crypto","secure","standards-based","nodejs","typescript","esmodule","lightweight","fast","modern","object"],"_id":"hashery@1.2.0","gitHead":"7856ec753fc47db68aba3f439995593f5777b71b","bugs":{"url":"https://github.com/jaredwray/hashery/issues"},"homepage":"https://github.com/jaredwray/hashery#readme","_nodeVersion":"22.21.1","_npmVersion":"10.9.4","dist":{"integrity":"sha512-43XJKpwle72Ik5Zpam7MuzRWyNdwwdf6XHlh8wCj2PggvWf+v/Dm5B0dxGZOmddidgeO6Ofu9As/o231Ti/9PA==","shasum":"a5f865f169aedd964d6e986cd56b03128df9af44","tarball":"https://registry.npmjs.org/hashery/-/hashery-1.2.0.tgz","fileCount":11,"unpackedSize":265299,"signatures":[{"keyid":"SHA256:DhQ8wR5APBvFHLF/+Tc+AYvPOdTpcIDqOhxsBHRwC7U","sig":"MEUCIBPtI0LLX5vKUgq223sYFpXvHsytESB17Ko3JKP3k6aAAiEAgPx8wRvkg9nFVm3yOcwL+58XBcA1X+950CHtEkqiIXg="}]},"_npmUser":{"name":"jaredwray","email":"me@jaredwray.com"},"directories":{},"maintainers":[{"name":"jaredwray","email":"me@jaredwray.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages-npm-production","tmp":"tmp/hashery_1.2.0_1763058884690_0.8101342782736329"},"_hasShrinkwrap":false}},"time":{"created":"2025-11-12T08:41:15.311Z","modified":"2025-11-13T18:34:45.068Z","1.0.0":"2025-11-12T08:41:15.488Z","1.1.0":"2025-11-12T17:58:03.396Z","1.2.0":"2025-11-13T18:34:44.875Z"},"bugs":{"url":"https://github.com/jaredwray/hashery/issues"},"author":{"name":"Jared Wray","email":"me@jaredwray.com"},"license":"MIT","homepage":"https://github.com/jaredwray/hashery#readme","keywords":["webcrypto","crypto.subtle","object-hash","hash","hashing","sha256","sha512","digest","deterministic","stable-hash","json-hash","browser-compatible","native-crypto","secure","standards-based","nodejs","typescript","esmodule","lightweight","fast","modern","object"],"repository":{"type":"git","url":"git+https://github.com/jaredwray/hashery.git"},"description":"Browser Compatible Object Hashing","maintainers":[{"name":"jaredwray","email":"me@jaredwray.com"}],"readme":"<img src=\"./site/logo.svg\" />\n\n# hashery\nBrowser / Nodejs Compatible Object Hashing\n\n[![tests](https://github.com/jaredwray/hashery/actions/workflows/tests.yml/badge.svg)](https://github.com/jaredwray/hashery/actions/workflows/tests.yml)\n[![codecov](https://codecov.io/gh/jaredwray/hashery/graph/badge.svg?token=JTuDzWoTRn)](https://codecov.io/gh/jaredwray/hashery)\n[![GitHub license](https://img.shields.io/github/license/jaredwray/hashery)](https://github.com/jaredwray/hashery/blob/master/LICENSE)\n[![npm](https://img.shields.io/npm/dm/hashery)](https://npmjs.com/package/hashery)\n[![jsDelivr](https://data.jsdelivr.com/v1/package/npm/hashery/badge)](https://www.jsdelivr.com/package/npm/hashery)\n[![npm](https://img.shields.io/npm/v/hashery)](https://npmjs.com/package/hashery)\n\n# Features\n- **Simple and Easy Object Hashing** - Object hashing based on multiple algorithms.\n- **Browser and Node.js Compatible** - Built using `WebCrypto` API for both environments\n- **Multiple Hash Algorithms** - Supports SHA-256, SHA-384, SHA-512 (WebCrypto), plus DJB2, FNV1, Murmer, and CRC32\n- **Synchronous & Asynchronous** - Both sync and async methods for flexible integration\n- **Custom Serialization** - Easily replace JSON `parse` and `stringify` with custom functions\n- **Deterministic Hashing** - Generate consistent hashes for the same input\n- **Hash to Number** - Convert hashes to deterministic numbers within a specified range. Great for slot management\n- **Provider System** - Extensible hash provider architecture for custom algorithms\n- **Fuzzy Provider Matching** - Case-insensitive and dash-tolerant algorithm name matching\n- **Hooks Support** - Extends Hookified for event-based functionality\n- **Maintained on a Regular Basis** - Active maintenance and updates\n\n# Table of Contents\n\n- [Features](#features)\n- [Installation](#installation)\n- [Usage](#usage)\n  - [Basic Hashing](#basic-hashing)\n  - [Synchronous Hashing](#synchronous-hashing)\n  - [Using Different Hash Algorithms](#using-different-hash-algorithms)\n  - [Setting a Default Algorithm](#setting-a-default-algorithm)\n  - [Truncating Hash Output](#truncating-hash-output)\n  - [Hash to Number (Great for Slot Management)](#hash-to-number-great-for-slot-management)\n  - [Hash to Number Synchronous](#hash-to-number-synchronous)\n  - [Browser Usage](#browser-usage)\n- [Hooks](#hooks)\n- [Web Crypto](#web-crypto)\n- [DJB2 Hashing](#djb2-hashing)\n- [FNV1 Hashing](#fnv1-hashing)\n- [CRC Hashing](#crc-hashing)\n- [API - Properties](#api---properties)\n  - [parse](#parse)\n  - [stringify](#stringify)\n  - [providers](#providers)\n  - [names](#names)\n  - [defaultAlgorithm](#defaultalgorithm)\n  - [defaultAlgorithmSync](#defaultalgorithmsync)\n- [API - Functions](#api---functions)\n  - [toHash(data, options?)](#toHashdata-options)\n  - [toHashSync(data, options?)](#toHashsyncdata-options)\n  - [toNumber(data, options?)](#tonumberdata-options)\n  - [toNumberSync(data, options?)](#tonumbersyncdata-options)\n  - [loadProviders(providers?, options?)](#loadprovidersproviders-options)\n- [Benchmarks](#benchmarks)\n- [Code of Conduct and Contributing](#code-of-conduct-and-contributing)\n- [License and Copyright](#license-and-copyright)\n\n# Installation\n\n```bash\nnpm install hashery\n```\n\n# Usage\n\n## Basic Hashing\n\n```typescript\nimport { Hashery } from 'hashery';\n\nconst hashery = new Hashery();\n\n// Hash an object (defaults to SHA-256)\nconst hash = await hashery.toHash({ name: 'John', age: 30 });\nconsole.log(hash); // SHA-256 hash string\n\n// Hash a string\nconst stringHash = await hashery.toHash('hello world');\n\n// Hash any value (numbers, arrays, etc.)\nconst numberHash = await hashery.toHash(42);\nconst arrayHash = await hashery.toHash([1, 2, 3, 4, 5]);\n```\n\n## Synchronous Hashing\n\nFor performance-critical applications or when you need to avoid async/await, use the synchronous hashing methods. These work with non-cryptographic hash algorithms (djb2, fnv1, murmer, crc32) and are significantly faster than WebCrypto methods.\n\n```typescript\nimport { Hashery } from 'hashery';\n\nconst hashery = new Hashery();\n\n// Synchronous hash (defaults to djb2)\nconst hash = hashery.toHashSync({ name: 'John', age: 30 });\nconsole.log(hash); // djb2 hash string (8 hex characters)\n\n// Sync with specific algorithm\nconst fnv1Hash = hashery.toHashSync({ data: 'example' }, { algorithm: 'fnv1' });\nconst murmerHash = hashery.toHashSync({ data: 'example' }, { algorithm: 'murmer' });\nconst crcHash = hashery.toHashSync({ data: 'example' }, { algorithm: 'crc32' });\n\n// Note: WebCrypto algorithms (SHA-256, SHA-384, SHA-512) are NOT supported in sync mode\n// This will throw an error:\n// hashery.toHashSync({ data: 'example' }, { algorithm: 'SHA-256' }); // ‚ùå Error!\n```\n\n## Using Different Hash Algorithms\n\n```typescript\nimport { Hashery } from 'hashery';\n\nconst hashery = new Hashery();\n\n// Use SHA-384\nconst hash384 = await hashery.toHash({ data: 'example' }, { algorithm: 'SHA-384' });\n\n// Use SHA-512\nconst hash512 = await hashery.toHash({ data: 'example' }, { algorithm: 'SHA-512' });\n\n// Use non-crypto hash algorithms\nconst fastHash = await hashery.toHash({ data: 'example' }, { algorithm: 'djb2' });\n```\n\n## Setting a Default Algorithm\n\nYou can set a default algorithm for all hash operations via constructor or property:\n\n```typescript\nimport { Hashery } from 'hashery';\n\n// Set default algorithm via constructor\nconst hashery = new Hashery({ defaultAlgorithm: 'SHA-512' });\n\n// Now all hashes use SHA-512 by default\nconst hash1 = await hashery.toHash({ data: 'example' }); // Uses SHA-512\nconsole.log(hash1.length); // 128 (SHA-512 produces 128 hex characters)\n\n// You can still override it per call\nconst hash2 = await hashery.toHash({ data: 'example' }, { algorithm: 'SHA-256' });\nconsole.log(hash2.length); // 64 (SHA-256 produces 64 hex characters)\n\n// Change default algorithm at runtime\nhashery.defaultAlgorithm = 'djb2';\nconst hash3 = await hashery.toHash({ data: 'example' }); // Uses djb2\n```\n\n## Truncating Hash Output\n\nYou can limit the length of the hash output using the `maxLength` option:\n\n```typescript\nimport { Hashery } from 'hashery';\n\nconst hashery = new Hashery();\n\n// Get a shorter hash (16 characters instead of 64)\nconst shortHash = await hashery.toHash(\n  { data: 'example' },\n  { algorithm: 'SHA-256', maxLength: 16 }\n);\nconsole.log(shortHash); // \"3f79bb7b435b0518\" (16 chars)\n\n// Full hash for comparison\nconst fullHash = await hashery.toHash({ data: 'example' });\nconsole.log(fullHash); // \"3f79bb7b435b05181e4ccf0d4e8...\" (64 chars)\n```\n\n## Hash to Number (Great for Slot Management)\n\n```typescript\nimport { Hashery } from 'hashery';\n\nconst hashery = new Hashery();\n\n// Convert hash to a number within a range\nconst slot = await hashery.toNumber({ userId: 123 }, { min: 0, max: 100 });\nconsole.log(slot); // Deterministic number between 0-100\n\n// Use for consistent slot assignment\nconst userSlot = await hashery.toNumber({ userId: 'user@example.com' }, { min: 0, max: 9 });\n// Same user will always get the same slot number\n```\n\n## Hash to Number Synchronous\n\nGenerate deterministic numbers synchronously for high-performance scenarios. Perfect for A/B testing, sharding, and load balancing without async overhead.\n\n```typescript\nimport { Hashery } from 'hashery';\n\nconst hashery = new Hashery();\n\n// Synchronous number generation (defaults to djb2)\nconst slot = hashery.toNumberSync({ userId: 123 }, { min: 0, max: 100 });\nconsole.log(slot); // Deterministic number between 0-100\n\n// A/B testing without async/await\nconst variant = hashery.toNumberSync({ userId: 'user123' }, { min: 0, max: 1 });\nconsole.log(variant === 0 ? 'Group A' : 'Group B');\n\n// Load balancing across servers\nconst serverIndex = hashery.toNumberSync(\n  { requestId: 'req_abc123' },\n  { min: 0, max: 9, algorithm: 'fnv1' } // 10 servers\n);\n\n// Sharding assignment\nconst shardId = hashery.toNumberSync(\n  { customerId: 'cust_xyz' },\n  { min: 0, max: 15, algorithm: 'murmer' } // 16 shards\n);\n\n// Set default sync algorithm for all sync operations\nconst hashery2 = new Hashery({ defaultAlgorithmSync: 'fnv1' });\nconst num = hashery2.toNumberSync({ data: 'test' }); // Uses fnv1 by default\n```\n\n## Browser Usage\n\nHashery works seamlessly in the browser using the Web Crypto API. You can include it via CDN or bundle it with your application.\n\n### Using via CDN (jsDelivr)\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Hashery Browser Example</title>\n</head>\n<body>\n  <script type=\"module\">\n    import { Hashery } from 'https://cdn.jsdelivr.net/npm/hashery@latest/dist/browser/index.js';\n\n    const hashery = new Hashery();\n\n    // Hash data in the browser\n    const hash = await hashery.toHash({ page: 'home', userId: 123 });\n    console.log('Hash:', hash);\n\n    // Generate slot numbers for A/B testing\n    const variant = await hashery.toNumber({ userId: 'user123' }, { min: 0, max: 1 });\n    console.log('A/B Test Variant:', variant === 0 ? 'A' : 'B');\n  </script>\n</body>\n</html>\n```\n\n# Hooks\n\nHashery extends [Hookified](https://github.com/jaredwray/hookified) to provide event-based functionality through hooks. Hooks allow you to intercept and modify behavior during the hashing process.\n\n## Available Hooks\n\n### Asynchronous Method Hooks\n\n#### `before:toHash`\n\nFired before hashing occurs. This hook receives a context object containing:\n- `data` - The data to be hashed (can be modified)\n- `algorithm` - The hash algorithm to use (can be modified)\n- `maxLength` - Optional maximum length for the hash output\n\n#### `after:toHash`\n\nFired after hashing completes. This hook receives a result object containing:\n- `hash` - The generated hash (can be modified)\n- `data` - The data that was hashed\n- `algorithm` - The algorithm that was used\n\n### Synchronous Method Hooks\n\n#### `before:toHashSync`\n\nFired before synchronous hashing occurs. This hook receives a context object containing:\n- `data` - The data to be hashed (can be modified)\n- `algorithm` - The hash algorithm to use (can be modified)\n- `maxLength` - Optional maximum length for the hash output\n\n**Note:** This hook fires asynchronously (non-blocking) to maintain the synchronous nature of `toHashSync()`. Hook execution happens in the background and won't delay the method's return.\n\n#### `after:toHashSync`\n\nFired after synchronous hashing completes. This hook receives a result object containing:\n- `hash` - The generated hash (can be modified)\n- `data` - The data that was hashed\n- `algorithm` - The algorithm that was used\n\n**Note:** This hook fires asynchronously (non-blocking) to maintain the synchronous nature of `toHashSync()`. Hook execution happens in the background.\n\n## Basic Hook Usage\n\n```typescript\nimport { Hashery } from 'hashery';\n\nconst hashery = new Hashery();\n\n// Listen to before:toHash hook\nhashery.onHook('before:toHash', async (context) => {\n  console.log('About to hash:', context.data);\n  console.log('Using algorithm:', context.algorithm);\n});\n\n// Listen to after:toHash hook\nhashery.onHook('after:toHash', async (result) => {\n  console.log('Hash generated:', result.hash);\n  console.log('Original data:', result.data);\n});\n\nawait hashery.toHash({ name: 'John', age: 30 });\n```\n\n## Modifying Data with Hooks\n\nYou can modify the data before it's hashed:\n\n```typescript\nconst hashery = new Hashery();\n\n// Add a timestamp to all hashed data\nhashery.onHook('before:toHash', async (context) => {\n  context.data = {\n    original: context.data,\n    timestamp: new Date().toISOString()\n  };\n});\n\nconst hash = await hashery.toHash({ userId: 123 });\n// Data will be hashed with timestamp included\n```\n\n## Modifying Algorithms with Hooks\n\nYou can force a specific algorithm regardless of what's requested:\n\n```typescript\nconst hashery = new Hashery();\n\n// Force all hashes to use SHA-512\nhashery.onHook('before:toHash', async (context) => {\n  context.algorithm = 'SHA-512';\n});\n\n// Even though we request SHA-256, it will use SHA-512\nconst hash = await hashery.toHash({ data: 'example' }, { algorithm: 'SHA-256' });\nconsole.log(hash.length); // 128 (SHA-512 hash length)\n```\n\n## Modifying Hash Results\n\nYou can transform the hash after it's generated:\n\n```typescript\nconst hashery = new Hashery();\n\n// Convert all hashes to uppercase\nhashery.onHook('after:toHash', async (result) => {\n  result.hash = result.hash.toUpperCase();\n});\n\nconst hash = await hashery.toHash({ data: 'example' });\nconsole.log(hash); // Hash will be in uppercase\n```\n\n## Implementing Caching with Hooks\n\nUse hooks to implement a caching layer:\n\n```typescript\nconst hashery = new Hashery();\nconst cache = new Map<string, string>();\n\n// Store hashes in cache after generation\nhashery.onHook('after:toHash', async (result) => {\n  const cacheKey = `${result.algorithm}:${JSON.stringify(result.data)}`;\n  cache.set(cacheKey, result.hash);\n});\n\n// Later you can check the cache before hashing\n// (Note: You would need to implement cache lookup logic in your application)\n```\n\n## Logging and Debugging\n\nHooks are perfect for logging and debugging:\n\n```typescript\nconst hashery = new Hashery();\n\nhashery.onHook('before:toHash', async (context) => {\n  console.log(`[DEBUG] Hashing data with ${context.algorithm}:`, context.data);\n});\n\nhashery.onHook('after:toHash', async (result) => {\n  console.log(`[DEBUG] Hash generated: ${result.hash.substring(0, 8)}...`);\n});\n\nawait hashery.toHash({ userId: 'user123' });\n```\n\n## Multiple Hooks\n\nYou can register multiple hooks, and they will execute in the order they were registered:\n\n```typescript\nconst hashery = new Hashery();\n\nhashery.onHook('before:toHash', async (context) => {\n  console.log('First hook');\n  context.data = { step: 1, original: context.data };\n});\n\nhashery.onHook('before:toHash', async (context) => {\n  console.log('Second hook');\n  context.data = { step: 2, previous: context.data };\n});\n\nawait hashery.toHash({ name: 'test' });\n// Output: \"First hook\" then \"Second hook\"\n// Data will be wrapped twice\n```\n\n## Synchronous Method Hooks\n\nSynchronous methods (`toHashSync`, `toNumberSync`) support hooks, but they fire asynchronously in the background to maintain the synchronous nature of the methods.\n\n```typescript\nconst hashery = new Hashery();\n\n// Listen to synchronous hash hooks\nhashery.onHook('before:toHashSync', async (context) => {\n  console.log('About to hash synchronously:', context.data);\n  console.log('Using algorithm:', context.algorithm);\n});\n\nhashery.onHook('after:toHashSync', async (result) => {\n  console.log('Sync hash generated:', result.hash);\n});\n\n// Call synchronous method - hooks fire in background\nconst hash = hashery.toHashSync({ name: 'John', age: 30 });\nconsole.log('Method returned:', hash);\n// Method returns immediately, hooks execute asynchronously\n```\n\n**Important Notes:**\n- Synchronous method hooks fire asynchronously (non-blocking)\n- The method returns immediately without waiting for hooks to complete\n- Hook modifications to context/result may not affect the returned value\n- For guaranteed hook execution, use async methods (`toHash`, `toNumber`)\n\n### Why Are Sync Hooks Asynchronous?\n\nSynchronous methods are designed for maximum performance. Making hooks blocking would defeat this purpose. The async hook execution allows:\n- Logging and monitoring without performance impact\n- Side effects (like caching) without blocking\n- Maintaining the synchronous contract of the method\n\nIf you need hooks that modify data or behavior, use the async methods (`toHash`, `toNumber`).\n\n## Removing Hooks\n\nYou can remove hooks when they're no longer needed:\n\n```typescript\nconst hashery = new Hashery();\n\nconst myHook = async (context: any) => {\n  console.log('Hook called');\n};\n\n// Add the hook\nhashery.onHook('before:toHash', myHook);\n\n// Remove the hook\nhashery.offHook('before:toHash', myHook);\n\n// Same works for sync hooks\nhashery.onHook('before:toHashSync', myHook);\nhashery.offHook('before:toHashSync', myHook);\n```\n\n## Error Handling in Hooks\n\nControl how errors in hooks are handled using the `throwOnEmitError` option:\n\n```typescript\n// Throw errors that occur in hooks\nconst hashery1 = new Hashery({ throwOnEmitError: true });\n\nhashery1.onHook('before:toHash', async (context) => {\n  throw new Error('Hook error');\n});\n\n// This will throw the error\nawait hashery1.toHash({ data: 'example' }); // Throws Error: Hook error\n\n// Silently handle errors in hooks\nconst hashery2 = new Hashery({ throwOnEmitError: false });\n\nhashery2.onHook('before:toHash', async (context) => {\n  throw new Error('Hook error');\n});\n\n// This will not throw, hashing continues\nconst hash = await hashery2.toHash({ data: 'example' }); // Returns hash successfully\n```\n\n# Web Crypto\n\nHashery is built on top of the Web Crypto API, which provides cryptographic operations in both browser and Node.js environments. This ensures consistent, secure hashing across all platforms.\n\n## Browser Support\n\nThe Web Crypto API is supported in all modern browsers:\n- Chrome 37+\n- Firefox 34+\n- Safari 11+\n- Edge 12+\n\n## Node.js Support\n\nNode.js 15+ includes the Web Crypto API via the `crypto.webcrypto` global. Hashery automatically detects and uses the appropriate crypto implementation for your environment.\n\n## Available Algorithms\n\n### Web Crypto Algorithms (Async Only)\nThese algorithms use the Web Crypto API and are only available asynchronously:\n- **SHA-256** - Secure Hash Algorithm 256-bit (default for async methods)\n- **SHA-384** - Secure Hash Algorithm 384-bit\n- **SHA-512** - Secure Hash Algorithm 512-bit\n\nThese are cryptographically secure and suitable for security-sensitive applications.\n\n### Non-Crypto Algorithms (Async & Sync)\nThese algorithms support both synchronous and asynchronous operation:\n- **djb2** - Fast hash function by Daniel J. Bernstein (default for sync methods)\n- **fnv1** - Fowler-Noll-Vo hash function\n- **murmer** - MurmurHash algorithm\n- **crc32** - Cyclic Redundancy Check 32-bit\n\n**Async methods** (`toHash`, `toNumber`):\n- Default to `SHA-256`\n- Can use any algorithm (WebCrypto or non-crypto)\n- Return Promises\n\n**Sync methods** (`toHashSync`, `toNumberSync`):\n- Default to `djb2`\n- Only work with non-crypto algorithms (djb2, fnv1, murmer, crc32)\n- Return values immediately\n- Throw an error if you try to use WebCrypto algorithms\n\n## Example: Using Web Crypto\n\n```typescript\nimport { Hashery } from 'hashery';\n\nconst hashery = new Hashery();\n\n// Web Crypto algorithms\nconst sha256 = await hashery.toHash({ data: 'example' }); // Default SHA-256\nconst sha384 = await hashery.toHash({ data: 'example' }, { algorithm: 'SHA-384' });\nconst sha512 = await hashery.toHash({ data: 'example' }, { algorithm: 'SHA-512' });\n\n// Non-crypto algorithms (faster, but not cryptographically secure)\nconst djb2Hash = await hashery.toHash({ data: 'example' }, { algorithm: 'djb2' });\nconst fnv1Hash = await hashery.toHash({ data: 'example' }, { algorithm: 'fnv1' });\n```\n\n# DJB2 Hashing\n\nDJB2 is a non-cryptographic hash function created by Daniel J. Bernstein. It's known for its simplicity and speed, making it ideal for hash tables, checksums, and other non-security applications.\n\n## Why Use DJB2?\n\n- **Fast Performance** - Significantly faster than cryptographic hash functions\n- **Good Distribution** - Provides good hash distribution for most data\n- **Simple Algorithm** - Easy to understand and implement\n- **Low Collision Rate** - Works well for hash tables and data structures\n- **Deterministic** - Same input always produces the same output\n\n## When to Use DJB2\n\n**Good for:**\n- Hash tables and data structures\n- Non-security checksums\n- Fast data lookups\n- Cache keys\n- General-purpose hashing where security isn't a concern\n\n**Not suitable for:**\n- Password hashing\n- Cryptographic signatures\n- Security-sensitive applications\n- Data integrity verification where tampering is a concern\n\n## DJB2 vs Cryptographic Hashes\n\n| Feature | DJB2 | SHA-256 |\n|---------|------|---------|\n| Speed | Very Fast | Slower |\n| Security | Not Secure | Cryptographically Secure |\n| Hash Length | 32-bit | 256-bit |\n| Collision Resistance | Good | Excellent |\n| Use Case | General Purpose | Security |\n\n## Example: Using DJB2\n\n```typescript\nimport { Hashery } from 'hashery';\n\nconst hashery = new Hashery();\n\n// Hash with DJB2 (fast, non-cryptographic)\nconst djb2Hash = await hashery.toHash({ userId: 123, action: 'login' }, { algorithm: 'djb2' });\n\n// Use for cache keys\nconst cacheKey = await hashery.toHash({\n  endpoint: '/api/users',\n  params: { page: 1, limit: 10 }\n}, { algorithm: 'djb2' });\n\n// Generate slot numbers with DJB2\nconst slot = await hashery.toNumber({ userId: 'user123' }, { min: 0, max: 99, algorithm: 'djb2' });\n```\n\n## Algorithm Details\n\nDJB2 uses a simple formula:\n```\nhash = 5381\nfor each character c:\n    hash = ((hash << 5) + hash) + c\n```\n\nThis translates to: `hash * 33 + c`, where 5381 is the magic initial value chosen by Daniel J. Bernstein for its distribution properties.\n\n# FNV1 Hashing\n\nFNV1 (Fowler-Noll-Vo) is a non-cryptographic hash function designed for fast hash table and checksum use. Created by Glenn Fowler, Landon Curt Noll, and Kiem-Phong Vo, it's known for its excellent distribution properties and simplicity.\n\n## Why Use FNV1?\n\n- **Excellent Distribution** - Superior hash distribution reduces collisions\n- **Fast Performance** - Very fast computation with minimal operations\n- **Simple Implementation** - Easy to understand and implement\n- **Public Domain** - No licensing restrictions\n- **Well-Tested** - Extensively used and tested in production systems\n- **Deterministic** - Same input always produces the same output\n\n## When to Use FNV1\n\n**Good for:**\n- Hash tables and associative arrays\n- Checksums and fingerprints\n- Data deduplication\n- Bloom filters\n- Fast lookups and indexing\n- Non-cryptographic applications\n\n**Not suitable for:**\n- Password hashing\n- Cryptographic signatures\n- Security-critical applications\n- Digital signatures\n- Data integrity in adversarial environments\n\n## FNV1 vs Other Hash Functions\n\n| Feature | FNV1 | DJB2 | SHA-256 |\n|---------|------|------|---------|\n| Speed | Very Fast | Very Fast | Slower |\n| Distribution | Excellent | Good | Excellent |\n| Security | Not Secure | Not Secure | Cryptographically Secure |\n| Collision Resistance | Good | Good | Excellent |\n| Use Case | Hash Tables | General Purpose | Security |\n\n## Example: Using FNV1\n\n```typescript\nimport { Hashery } from 'hashery';\n\nconst hashery = new Hashery();\n\n// Hash with FNV1 (fast, excellent distribution)\nconst fnv1Hash = await hashery.toHash({ productId: 'ABC123', variant: 'red' }, { algorithm: 'fnv1' });\n\n// Use for hash table keys\nconst tableKey = await hashery.toHash({\n  userId: 'user@example.com',\n  resource: 'profile'\n}, { algorithm: 'fnv1' });\n\n// Generate distributed slot numbers with FNV1\nconst slot = await hashery.toNumber({ sessionId: 'sess_xyz789' }, { min: 0, max: 999, algorithm: 'fnv1' });\n\n// Use for data deduplication\nconst fingerprint = await hashery.toHash({\n  content: 'document content here',\n  metadata: { author: 'John', date: '2024-01-01' }\n}, { algorithm: 'fnv1' });\n```\n\n## Algorithm Details\n\nFNV1 uses the following formula:\n```\nhash = FNV_offset_basis\nfor each byte b:\n    hash = hash * FNV_prime\n    hash = hash XOR b\n```\n\nWhere:\n- **FNV_offset_basis**: Initial hash value (different for 32-bit, 64-bit, etc.)\n- **FNV_prime**: A carefully chosen prime number for good distribution\n- **XOR**: Bitwise exclusive OR operation\n\nThe algorithm multiplies by a prime and XORs with each input byte, creating excellent avalanche properties where small input changes result in very different hash values.\n\n# CRC Hashing\n\nCRC (Cyclic Redundancy Check) is a non-cryptographic hash function designed primarily for detecting accidental changes to data. CRC32 is a 32-bit variant widely used in network protocols, file formats, and data integrity verification.\n\n## Why Use CRC?\n\n- **Error Detection** - Excellent at detecting accidental data corruption\n- **Industry Standard** - Widely used in ZIP, PNG, Ethernet, and many other standards\n- **Fast Performance** - Very efficient computation using lookup tables\n- **Hardware Support** - Often implemented in hardware for maximum speed\n- **Well-Understood** - Decades of use and mathematical analysis\n- **Deterministic** - Same input always produces the same output\n\n## When to Use CRC\n\n**Good for:**\n- Data integrity verification\n- Error detection in network protocols\n- File format checksums (ZIP, PNG, etc.)\n- Storage integrity checks\n- Detecting accidental corruption\n- Quick data validation\n\n**Not suitable for:**\n- Cryptographic applications\n- Password hashing\n- Digital signatures\n- Security-sensitive checksums\n- Protection against intentional tampering\n- Hash tables (not designed for this use case)\n\n## CRC vs Other Hash Functions\n\n| Feature | CRC32 | DJB2 | FNV1 | SHA-256 |\n|---------|-------|------|------|---------|\n| Primary Use | Error Detection | Hash Tables | Hash Tables | Security |\n| Speed | Very Fast | Very Fast | Very Fast | Slower |\n| Security | Not Secure | Not Secure | Not Secure | Cryptographically Secure |\n| Hash Length | 32-bit | 32-bit | 32-bit/64-bit | 256-bit |\n| Error Detection | Excellent | Poor | Poor | Excellent |\n| Use Case | Data Integrity | General Purpose | Hash Tables | Security |\n\n## Example: Using CRC\n\n```typescript\nimport { Hashery } from 'hashery';\n\nconst hashery = new Hashery();\n\n// Hash with CRC32 for data integrity\nconst crcHash = await hashery.toHash({ fileData: 'content here' }, { algorithm: 'crc32' });\n\n// Verify file integrity\nconst fileChecksum = await hashery.toHash({\n  filename: 'document.pdf',\n  size: 1024000,\n  modified: '2024-01-01'\n}, { algorithm: 'crc32' });\n\n// Network packet validation\nconst packetChecksum = await hashery.toHash({\n  header: { type: 'data', seq: 123 },\n  payload: 'packet payload data'\n}, { algorithm: 'crc32' });\n\n// Quick data validation\nconst dataIntegrity = await hashery.toHash({\n  recordId: 'rec_123',\n  data: { field1: 'value1', field2: 'value2' }\n}, { algorithm: 'crc32' });\n```\n\n## Algorithm Details\n\nCRC32 uses polynomial division in a finite field (GF(2)):\n\n```\nCRC32 polynomial: 0x04C11DB7 (IEEE 802.3 standard)\n\nfor each byte b:\n    crc = (crc >> 8) XOR table[(crc XOR b) & 0xFF]\n```\n\nKey characteristics:\n- **Polynomial**: Uses a standardized polynomial for consistent results\n- **Lookup Table**: Pre-computed table for fast calculation\n- **Bit Shifting**: Efficient XOR and shift operations\n- **Finite Field**: Mathematical properties ensure good error detection\n\n## Important Notes\n\n‚ö†Ô∏è **Security Warning**: CRC is NOT cryptographically secure. It's designed to detect accidental errors, not intentional tampering. For security applications, use SHA-256 or other cryptographic hash functions.\n\n‚úÖ **Best Practice**: Use CRC32 for checksums and error detection in non-adversarial environments. Use cryptographic hashes (SHA-256, SHA-512) when security matters.\n\n# API - Properties\n\n## `parse`\n\nGets or sets the parse function used to deserialize stored values.\n\n**Type:** `ParseFn`\n\n**Default:** `JSON.parse`\n\n```typescript\nconst hashery = new Hashery();\nhashery.parse = customParseFunction;\n```\n\n## `stringify`\n\nGets or sets the stringify function used to serialize values for storage.\n\n**Type:** `StringifyFn`\n\n**Default:** `JSON.stringify`\n\n```typescript\nconst hashery = new Hashery();\nhashery.stringify = customStringifyFunction;\n```\n\n## `providers`\n\nGets or sets the HashProviders instance used to manage hash providers.\n\n**Type:** `HashProviders`\n\n```typescript\nconst hashery = new Hashery();\nconsole.log(hashery.providers);\n```\n\n## `names`\n\nGets the names of all registered hash algorithm providers.\n\n**Type:** `Array<string>`\n\n**Returns:** An array of provider names (e.g., ['SHA-256', 'SHA-384', 'SHA-512', 'djb2', 'fnv1', 'murmer', 'crc32'])\n\n```typescript\nconst hashery = new Hashery();\nconsole.log(hashery.names); // ['SHA-256', 'SHA-384', 'SHA-512', 'djb2', 'fnv1', 'murmer', 'crc32']\n```\n\n## `defaultAlgorithm`\n\nGets or sets the default hash algorithm to use when none is specified for async methods.\n\n**Type:** `string`\n\n**Default:** `'SHA-256'`\n\n```typescript\nconst hashery = new Hashery();\n\n// Get default algorithm\nconsole.log(hashery.defaultAlgorithm); // 'SHA-256'\n\n// Set default algorithm\nhashery.defaultAlgorithm = 'SHA-512';\n\n// Now all async hashes use SHA-512 by default\nconst hash = await hashery.toHash({ data: 'example' });\nconsole.log(hash.length); // 128 (SHA-512 produces 128 hex characters)\n```\n\n## `defaultAlgorithmSync`\n\nGets or sets the default hash algorithm to use when none is specified for synchronous methods.\n\n**Type:** `string`\n\n**Default:** `'djb2'`\n\n```typescript\nconst hashery = new Hashery();\n\n// Get default sync algorithm\nconsole.log(hashery.defaultAlgorithmSync); // 'djb2'\n\n// Set default sync algorithm\nhashery.defaultAlgorithmSync = 'fnv1';\n\n// Now all sync hashes use fnv1 by default\nconst hash = hashery.toHashSync({ data: 'example' });\n\n// You can also set it in the constructor\nconst hashery2 = new Hashery({ defaultAlgorithmSync: 'murmer' });\nconst hash2 = hashery2.toHashSync({ data: 'test' }); // Uses murmer\n```\n\n# API - Functions\n\n## `toHash(data, options?)`\n\nGenerates a cryptographic hash of the provided data using the specified algorithm (async). The data is first stringified using the configured stringify function, then hashed.\n\n**Parameters:**\n- `data` (unknown) - The data to hash (will be stringified before hashing)\n- `options` (object, optional) - Configuration options\n  - `algorithm` (string, optional) - The hash algorithm to use (defaults to 'SHA-256')\n  - `maxLength` (number, optional) - Maximum length for the hash output (truncates from the start)\n\n**Returns:** `Promise<string>` - A Promise that resolves to the hexadecimal string representation of the hash\n\n**Example:**\n\n```typescript\nconst hashery = new Hashery();\n\n// Using default SHA-256\nconst hash = await hashery.toHash({ name: 'John', age: 30 });\n\n// Using a different algorithm\nconst hash512 = await hashery.toHash({ name: 'John' }, { algorithm: 'SHA-512' });\nconst fastHash = await hashery.toHash({ name: 'John' }, { algorithm: 'djb2' });\n\n// Truncating hash output\nconst shortHash = await hashery.toHash(\n  { name: 'John' },\n  { algorithm: 'SHA-256', maxLength: 16 }\n);\n```\n\n## `toHashSync(data, options?)`\n\nGenerates a hash of the provided data synchronously using a non-cryptographic hash algorithm. The data is first stringified using the configured stringify function, then hashed.\n\n**Important:** This method only works with synchronous hash providers (djb2, fnv1, murmer, crc32). WebCrypto algorithms (SHA-256, SHA-384, SHA-512) are not supported and will throw an error.\n\n**Parameters:**\n- `data` (unknown) - The data to hash (will be stringified before hashing)\n- `options` (object, optional) - Configuration options\n  - `algorithm` (string, optional) - The hash algorithm to use (defaults to 'djb2')\n  - `maxLength` (number, optional) - Maximum length for the hash output (truncates from the start)\n\n**Returns:** `string` - The hexadecimal string representation of the hash\n\n**Throws:** `Error` if the specified algorithm does not support synchronous hashing\n\n**Example:**\n\n```typescript\nconst hashery = new Hashery();\n\n// Using default djb2\nconst hash = hashery.toHashSync({ name: 'John', age: 30 });\n\n// Using a different algorithm\nconst hashFnv1 = hashery.toHashSync({ name: 'John' }, { algorithm: 'fnv1' });\nconst hashMurmer = hashery.toHashSync({ name: 'John' }, { algorithm: 'murmer' });\nconst hashCrc = hashery.toHashSync({ name: 'John' }, { algorithm: 'crc32' });\n\n// Truncating hash output\nconst shortHash = hashery.toHashSync(\n  { name: 'John' },\n  { algorithm: 'djb2', maxLength: 4 }\n);\n\n// This will throw an error (WebCrypto not supported in sync mode)\n// const invalid = hashery.toHashSync({ name: 'John' }, { algorithm: 'SHA-256' }); // ‚ùå\n```\n\n## `toNumber(data, options?)`\n\nGenerates a deterministic number within a specified range based on the hash of the provided data (async). This method uses the toHash function to create a consistent hash, then maps it to a number between min and max (inclusive).\n\n**Parameters:**\n- `data` (unknown) - The data to hash (will be stringified before hashing)\n- `options` (object, optional) - Configuration options\n  - `min` (number, optional) - The minimum value of the range (inclusive, defaults to 0)\n  - `max` (number, optional) - The maximum value of the range (inclusive, defaults to 100)\n  - `algorithm` (string, optional) - The hash algorithm to use (defaults to 'SHA-256')\n  - `hashLength` (number, optional) - Number of characters from hash to use for conversion (defaults to 16)\n\n**Returns:** `Promise<number>` - A Promise that resolves to a number between min and max (inclusive)\n\n**Throws:** Error if min is greater than max\n\n**Example:**\n\n```typescript\nconst hashery = new Hashery();\n\n// Generate a number between 0 and 100 (default range)\nconst num = await hashery.toNumber({ user: 'john' });\n\n// Generate a number with custom range\nconst num2 = await hashery.toNumber({ user: 'john' }, { min: 0, max: 100 });\n\n// Using a different algorithm\nconst num512 = await hashery.toNumber({ user: 'john' }, { min: 0, max: 255, algorithm: 'SHA-512' });\n```\n\n## `toNumberSync(data, options?)`\n\nGenerates a deterministic number within a specified range based on the hash of the provided data synchronously. This method uses the toHashSync function to create a consistent hash, then maps it to a number between min and max (inclusive).\n\n**Important:** This method only works with synchronous hash providers (djb2, fnv1, murmer, crc32).\n\n**Parameters:**\n- `data` (unknown) - The data to hash (will be stringified before hashing)\n- `options` (object, optional) - Configuration options\n  - `min` (number, optional) - The minimum value of the range (inclusive, defaults to 0)\n  - `max` (number, optional) - The maximum value of the range (inclusive, defaults to 100)\n  - `algorithm` (string, optional) - The hash algorithm to use (defaults to 'djb2')\n  - `hashLength` (number, optional) - Number of characters from hash to use for conversion (defaults to 16)\n\n**Returns:** `number` - A number between min and max (inclusive)\n\n**Throws:**\n- Error if min is greater than max\n- Error if the specified algorithm does not support synchronous hashing\n\n**Example:**\n\n```typescript\nconst hashery = new Hashery();\n\n// Generate a number between 0 and 100 (default range)\nconst num = hashery.toNumberSync({ user: 'john' });\n\n// Generate a number with custom range\nconst slot = hashery.toNumberSync({ user: 'john' }, { min: 0, max: 9 });\n\n// Using a different algorithm\nconst numFnv1 = hashery.toNumberSync({ user: 'john' }, { min: 0, max: 255, algorithm: 'fnv1' });\n\n// A/B testing\nconst variant = hashery.toNumberSync({ userId: 'user123' }, { min: 0, max: 1 });\nconsole.log(variant === 0 ? 'Group A' : 'Group B');\n\n// Load balancing\nconst serverId = hashery.toNumberSync(\n  { requestId: 'req_abc' },\n  { min: 0, max: 9, algorithm: 'murmer' } // 10 servers\n);\n\n// This will throw an error (WebCrypto not supported in sync mode)\n// const invalid = hashery.toNumberSync({ user: 'john' }, { algorithm: 'SHA-256' }); // ‚ùå\n```\n\n## `loadProviders(providers?, options?)`\n\nLoads hash providers into the Hashery instance. This allows you to add custom hash providers or replace the default ones.\n\n**Parameters:**\n- `providers` (Array<HashProvider>, optional) - Array of hash providers to add\n- `options` (HasheryLoadProviderOptions, optional) - Options object\n  - `includeBase` (boolean) - Whether to include base providers (default: true)\n\n**Returns:** `void`\n\n**Example:**\n\n```typescript\nconst hashery = new Hashery();\n\n// Add a custom provider\nconst customProvider = {\n  name: 'custom',\n  toHash: async (data: BufferSource) => 'custom-hash'\n};\n\nhashery.loadProviders([customProvider]);\n\n// Load without base providers\nhashery.loadProviders([customProvider], { includeBase: false });\n```\n\n# Benchmarks\n\nOverall view of the current algorithm's and their performance using simple hashing with random data. Many of these are not secure and should be used only for object hashing. Read about each one in the documentation and pick what works best for your use case.\n\n|   name    |  summary  |  ops/sec  |  time/op  |  margin  |  samples  |\n|-----------|:---------:|----------:|----------:|:--------:|----------:|\n|  DJB2     |    ü•á     |     522K  |      2¬µs  |  ¬±0.86%  |     506K  |\n|  MURMER   |  -0.24%   |     521K  |      2¬µs  |  ¬±0.96%  |     504K  |\n|  FNV1     |   -3.9%   |     501K  |      2¬µs  |  ¬±0.27%  |     487K  |\n|  CRC32    |   -12%    |     457K  |      2¬µs  |  ¬±0.22%  |     446K  |\n|  SHA-256  |   -81%    |      98K  |     10¬µs  |  ¬±0.20%  |      96K  |\n|  SHA-384  |   -83%    |      90K  |     12¬µs  |  ¬±2.88%  |      85K  |\n|  SHA-512  |   -83%    |      86K  |     12¬µs  |  ¬±0.58%  |      84K  |\n\n# Code of Conduct and Contributing\nPlease use our [Code of Conduct](CODE_OF_CONDUCT.md) and [Contributing](CONTRIBUTING.md) guidelines for development and testing. We appreciate your contributions!\n\n# License and Copyright\n\n[MIT](LICENSE) & ¬© [Jared Wray](https://jaredwray.com)","readmeFilename":"README.md"}